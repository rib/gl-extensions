GLX_EXT_buffer_age

    EXT_buffer_age

Name Strings

    GLX_EXT_buffer_age

Notice

    Copyright 2011 Intel Cooperation. All rights reserved.

Contributors

    Robert Bragg
    Neil Roberts
    Tapani Pälli
    Kristian Høgsberg

Contacts

    Robert Bragg, Intel (robert.bragg 'at' intel.com)

Status

    Draft

Version

    4 - Mar 21, 2012

Number

    TBD

Dependencies

    Requires GLX 1.4

    This extension is written against the wording of the GLX 1.4 
    Specification.

Overview

    The aim of this extension is to expose enough information to
    applications about how the driver manages the set of front and
    back buffers associated with a given surface to allow applications
    to re-use the contents of old frames and minimize how much must be
    redrawn for the next frame.

    There are lots of different ways for a driver to manage these
    buffers, from double buffering, different styles of triple
    buffering and even n-buffering or simply single buffer rendering.
    We also need to consider that power management events or memory
    pressure events might also result in some of the buffers not
    currently in-use being freed.
   
    This extension lets you query the age of the back buffer contents
    for an GLX surface as the number of frames elapsed since the
    contents were originally defined. The back buffer can either be
    reported as invalid (has an age of 0) or it may be reported to
    contain the contents from n frames prior to this new frame.

    Once the age has been queried then it can be assumed to remain
    unchanged until the end of that frame.

    For example if you consider a double buffered application drawing
    a small spinning icon, but everything else in the scene is static.
    If we know that 2 buffers are continuously being recycled each
    time glXSwapBuffers is called then even though 100s of frames may
    need to be drawn to animate the icon it can be seen that the two
    buffers are remaining unchanged except within the bounds of the
    icon. In this scenario ideally the application would simply
    perform an incremental update of the old buffer instead of
    redundantly redrawing all the static parts of the scene. The
    problem up until now though has been that GLX doesn't report how
    buffers may be recycled so it wasn't safe for applications to try
    and reuse their contents. Now applications can keep track of all
    the regions that have changed over the last n frames and by
    knowing the age of the buffer they know how to efficiently repair
    buffers that are re-cycled instead of redrawing the entire scene.

New Procedures and Functions

    None

New Tokens

    GLX_BUFFER_AGE_EXT    TBD

Additions to Section 3.3.6 of the GLX 1.4 Specification (Querying Attributes)

    Add the following text to the description for glXQueryDrawable

	    Querying GLX_BUFFER_AGE_EXT returns the age of the
	color contents of the current back-buffer as the number of
	frames elapsed since it was defined. For example with a single
	buffered surface the age would usually be 1. With a double
	buffered surface the age would usually be 2. An age of 0 means
	that the contents have only just been initialized and the
	contents are undefined.
	    Once GLX_BUFFER_AGE_EXT has been queried then it can be
	assumed that the age will remain valid until the end of the
	frame such as when glXSwapBuffers is next called.
	    If the returned age is greater than zero then it can be
	assumed that when the buffer contents were created then every
	pixel was owned by the current context and would have passed
	the pixel ownership test.
	    If the GLX driver decides to free un-used back-buffers
	when the system is under memory pressure or in response to
	power-management events then GLX will return an age of 0 when
	it allocates a new buffer at the start of a new frame.
	    Applications can use this age to safely rely on the
	contents of old back-buffers to potentially reduce the amount
	of redrawing they do each frame.

    Add the following text to the last paragraph of the description for
    glXQueryDrawable describing error conditions.
       
       If querying GLX_BUFFER_AGE_EXT and <draw> is not bound to the
       calling threads current context a GLXBadDrawable error is
       generated.

Dependencies on OpenGL

    None

Issues

    How can an application know that all pixels of a re-usable buffer
    were originally owned by the current context?

	RESOLVED: the driver must discount any buffer when it is not
	fully owned by the context drawing to it. (If any pixel would
	fail the pixel ownership test.)

	Some drivers may share the back buffer between different
	contexts and so it's possible with overlapping windows that
	some regions of the back buffer aren't owned by the current
	context (they fail the pixel ownership test) which could make
	it difficult for applications to re-use such a buffer later if
	it doesn't know exactly what regions belong to it.

	An alternative to discounting partially owned buffers is that
	we add a way to query the region of owned pixels, but we chose
	to keep the solution simple to easy implementation.

    What are the semantics if the buffer age attribute is queried for
    a drawable that isn't bound to the calling thread's context?
       
	RESOLVED: we report an GLXBadDrawable error.

Revision History

    Version 1, 07/02/2012
      - First draft
    Version 2, 08/03/2012
      - Document that once the age is queried it remains valid until
	the end of the frame.
    Version 3, 08/03/2012
      - Clarify that only buffers who's contents were fully owned by
        the context are tracked.
    Version 4 21/03/2012
      - Document that an error will be generated if querying the age
        for a drawable not bound to the current context.

