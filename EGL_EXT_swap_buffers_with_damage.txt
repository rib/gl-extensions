EGL_EXT_swap_buffers_with_damage

    EXT_swap_buffers_with_damage

Name Strings

    EGL_EXT_swap_buffers_with_damage

Notice

    Copyright 2011,2012,2013 Intel Cooperation. All rights reserved.

Contributors

    Robert Bragg
    Tapani Pälli
    Kristian Høgsberg
    Benjamin Franzke

Contacts

    Robert Bragg, Intel (robert.bragg 'at' intel.com)

Status

    Draft

Version

    6 - Feb 5, 2013

Number

    TBD

Dependencies

    Requires EGL 1.4

    This extension is written against the wording of the EGL 1.4
    Specification.

Overview

    This extension provides a means to issue a swap buffers request to
    display the contents of the current back buffer and also specify a
    list of damage rectangles that can be passed to a system
    compositor so it can minimize how much it has to recompose.

    This should be used in situations where an application is only
    animating a small portion of a surface since it enables the
    compositor to avoid wasting time recomposing parts of the surface
    that haven't changed.

New Procedures and Functions

    EGLBoolean eglSwapBuffersWithDamageEXT (
	EGLDisplay dpy,
	EGLSurface surface,
	EGLint *rects,
	EGLint n_rects);

New Tokens

    None

Changes to Chapter 3 of the EGL 1.4 Specification (EGL Functions and Errors)

    Add the following text to subsection 3.9.1 titled "Posting to a
    Window" after the description of eglSwapBuffers.

	As an alternative to eglSwapBuffers use:

	EGLBoolean eglSwapBuffersWithDamageEXT (
	    EGLDisplay dpy,
	    EGLSurface surface,
	    EGLint *rects,
	    EGLint n_rects);

	to do the same thing as eglSwapBuffers but additionally report
	a list of rectangles that define the region that has truly
	changed since the last frame. To be clear; the entire contents
	of the back buffer will still be swapped to the front so
	applications using this API must still ensure that the entire
	back buffer is consistent. The rectangles are only a hint for
	the system compositor so it can avoid recomposing parts of the
	surface that haven't really changed.
	    <rects> points to a list of integers in groups of four that
	each describe a rectangle in screen coordinates in this
	layout: {x, y, width, height}. The rectangles are specified
	relative to the top-left of the surface and the x and y
	components of each rectangle specify the top-left position of
	that rectangle. <n_rects> determines how many groups of 4
	integers can be read from <rects>.  It is not necessary to
	avoid overlaps of the specified rectangles.
            If <n_rects> is 0 then <rects> is ignored and the entire
        surface is implicitly damaged and the behaviour is equivalent
        to calling eglSwapBuffers.
            The error conditions checked for are the same as for the
        eglSwapBuffers api.

    Modify the first paragraph of Section 3.9.1 titled "Native Window
    Resizing"
    
        "If the native window corresponding to <surface> has been
        resized prior to the swap, <surface> must be resized to match.
        <surface> will normally be resized by the EGL implementation
        at the time the native window is resized. If the
        implementation cannot do this transparently to the client,
        then eglSwapBuffers and eglSwapBuffersWithDamageEXT must
        detect the change and resize surface prior to copying its
        pixels to the native window."

    Modify the following sentences in Section 3.9.3, page 51 (Posting
    Semantics)

    Paragraph 2, first sentence:

        "If <dpy> and <surface> are the display and surface for the
        calling thread's current context, eglSwapBuffers,
        eglSwapBuffersWithDamageEXT, and eglCopyBuffers perform an
        implicit flush operation on the context (glFlush for OpenGL or
        OpenGL ES context, vgFlush for an OpenVG context)."

    Paragraph 3, first sentence:

        "The destination of a posting operation (a visible window, for
        eglSwapBuffers or eglSwapBuffersWithDamageEXT, or a native
        pixmap, for eglCopyBuffers) should have the same number of
        components and component sizes as the color buffer it's being
        copied from."

    Paragraph 6, first two sentences:

        "The function

            EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint
                interval);

        specifies the minimum number of video frame periods per color
        buffer post operation for the window associated with the
        current context. The interval takes effect when eglSwapBuffers
        or eglSwapBuffersWithDamageEXT is first called subsequent to
        the eglSwapInterval call."

    Modify the following sentences in Section 3.9.4, page 52 (Posting
    Errors)

    Paragraph 1, first sentence:

        "eglSwapBuffers, eglSwapBuffersWithDamageEXT, and
        eglCopyBuffers return EGL_FALSE on failure."

    Paragraph 1, seventh sentence:

        "If eglSwapBuffers or eglSwapBuffersWithDamageEXT are called
        and the native window associated with <surface> is no longer
        valid, an EGL_BAD_NATIVE_WINDOW error is generated.  If
        eglSwapBuffersWithDamageEXT is called and <n_rects>, is less
        than zero or <n_rects> is greater than zero but <rects> is
        NULL, EGL_BAD_PARAMETER is generated."

Dependencies on OpenGL ES

    None

Dependencies on OpenVG

    None

Issues

1)  Do applications have to make sure the rectangles don't overlap?

    RESOLVED: No, that would be inconvenient for applications and we
    see no difficulty for implementations to supporting overlapping
    rectangles.

2)  Would it be valid for an implementation to discard the list of
    rectangles internally and work just in terms of the
    eglSwapBuffers api?

    RESOLVED: Yes, the rectangles are only there for optimization
    purposes so although it wouldn't be beneficial to applications if
    it was convenient at times then it would be compliant for an
    implementation to discard the rectangles and just call
    eglSwapBuffers instead. The error conditions that should be
    checked for are compatible with the requirements for
    eglSwapBuffers.

Revision History

    Version 1, 29/07/2011
      - First draft
    Version 2, 03/08/2011
      - Clarify that the rectangles passed may overlap
    Version 3, 01/09/2011
      - Fix a missing '*' in prototype to make rects a pointer
    Version 4, 11,02,2012
      - Clarify that implementing in terms of eglSwapBuffers would be
	compliant.
    Version 5, 11,02,2012
      - Tweak the cases where we report BAD_PARAMETER errors
    Version 6, 05/02/2013
      - Specify more thorough updates across the EGL 1.4 spec
        wherever it relates to the eglSwapBuffers api
      - Clarify that passing <n_rects> of 0 behaves as if
        eglSwapBuffers were called.
